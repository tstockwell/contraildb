package com.googlecode.contraildb.cvm.wrapper;

import com.contrail.cvm.wrapper.model.ClassItem;
import com.contraildb.cvm.utils.Utils;

import java.nio.charset.Charset;
import java.text.SimpleDateFormat;
import java.util.Comparator;
import java.util.Date;
import java.util.TreeSet;
import org.apache.bcel.classfile.Field;
import org.apache.bcel.classfile.JavaClass;
import org.apache.bcel.classfile.Method;
import org.apache.bcel.generic.Type;

public class GenerateStubDialog extends javax.swing.JDialog implements Runnable
{
    public static final String MACROS_CLASSNAME = "%%CLASS_NAME%%";
    public static final String MACROS_STATICFIELDS = "%%STATIC_FIELDS%%";
    public static final String MACROS_DYNAMICFIELDS = "%%DYNAMIC_FIELDS%%";
    public static final String MACROS_STATICMETHODS = "%%STATIC_METHODS%%";
    public static final String MACROS_DYNAMICMETHODS = "%%DYNAMIC_METHODS%%";
    public static final String MACROS_NEWINSTANCES = "%%NEW_INSTANCES%%";

    public static final long serialVersionUID = 121273223l;
    protected volatile String s_Error;
    protected volatile ClassItem[] ap_Classes;
    protected volatile String s_Result;
    protected volatile boolean lg_Working;

    /** Creates new form GenerateStubDialog */
    public GenerateStubDialog(java.awt.Frame parent)
    {
        super(parent, true);
        initComponents();

        Utils.toScreenCenter(this);
    }

    public synchronized String process(ClassItem[] _items)
    {
        try
        {
            lg_Working = true;

            s_Result = null;
            s_Error = null;
            ap_Classes = _items;

            new Thread(this).start();
            setVisible(true);

            return s_Result;
        }
        catch (Throwable ex)
        {
            s_Error = ex.getMessage();
            ex.printStackTrace();
            return null;
        }
    }

    public String getError()
    {
        return s_Error;
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        p_Button_Cancel = new javax.swing.JButton();
        jProgressBar1 = new javax.swing.JProgressBar();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        setTitle("Stub generating process");
        setResizable(false);

        p_Button_Cancel.setText("Cancel");
        p_Button_Cancel.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                p_Button_CancelActionPerformed(evt);
            }
        });

        jProgressBar1.setIndeterminate(true);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jProgressBar1, javax.swing.GroupLayout.DEFAULT_SIZE, 288, Short.MAX_VALUE)
                    .addComponent(p_Button_Cancel, javax.swing.GroupLayout.Alignment.TRAILING))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jProgressBar1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(p_Button_Cancel)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void p_Button_CancelActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_p_Button_CancelActionPerformed
    {//GEN-HEADEREND:event_p_Button_CancelActionPerformed
        lg_Working = false;
    }//GEN-LAST:event_p_Button_CancelActionPerformed

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JProgressBar jProgressBar1;
    private javax.swing.JButton p_Button_Cancel;
    // End of variables declaration//GEN-END:variables

    @Override
    public void run()
    {
        try
        {
            final String SPACER = "\t";

            Thread.sleep(500);
            String s_template = new String(Utils.loadResourceFromJAR(this.getClass(), "/template/template.txt"), Charset.forName("UTF-8"));

            SimpleDateFormat p_date = new SimpleDateFormat("EEE, d MMM yyyy HH:mm:ss");
            String s_date = p_date.format(new Date());

            s_template = s_template.replace((CharSequence)"%%DATETIME%%",(CharSequence) s_date);
            s_template = s_template.replace((CharSequence)"%%GENERATOR%%",(CharSequence)(main.APPLICATION+" "+main.VERSION));

            if (!lg_Working) return;
            
            StringBuilder p_staticFieldsBuffer = new StringBuilder(16384);
            StringBuilder p_synamicFieldsBuffer = new StringBuilder(16384);
            StringBuilder p_staticMethodsBuffer = new StringBuilder(16384);
            StringBuilder p_dynamicMethodsBuffer = new StringBuilder(16384);
            StringBuilder p_newInstancesBuffer = new StringBuilder(16384);

            boolean lg_classAdded = false;

            final String MACRO_NEWINSTANCE = "$if (_class.equals(\"%%SUNCLASS_NAME%%\")) s_class = \"%%CLASS_NAME%%\";\r\n".replace((CharSequence)"$",(CharSequence)SPACER);
            final String MACRO_CLASSNAMEHEAD = "$//--------------------------------------------------\r\n$// %%CLASS_NAME%%\r\n$//--------------------------------------------------\r\n".replace((CharSequence)"$",(CharSequence)SPACER);

            final String MACRO_METHOD = "$if (_method.equals(\"%%METHOD_NAME%%\"))\r\n${\r\n$$throw new UnsupportedOperationException(\"%%NORMALMETHOD_NAME%%\");\r\n$}\r\n".replace((CharSequence)"$",(CharSequence)SPACER);
            final String MACRO_FIELD = "$if (_fieldidentifier.equals(\"%%FIELD_NAME%%\"))\r\n${\r\n$$throw new UnsupportedOperationException(\"%%NORMALFIELD_NAME%%\");\r\n$}\r\n".replace((CharSequence)"$",(CharSequence)SPACER);

            for(int li=0;li<ap_Classes.length;li++)
            {
                if (!lg_Working) return;

                ClassItem p_class = ap_Classes[li];

                String s_className = p_class.getJavaClass().getClassName();
                
                String s_classHeader = MACRO_CLASSNAMEHEAD.replace((CharSequence)"%%CLASS_NAME%%",(CharSequence)s_className);


                String s_sunClassName = p_class.getJavaClass().getClassName().replace('.', '/');

                JavaClass p_javaClass = p_class.getJavaClass();
                if (!p_javaClass.isAbstract() && !p_javaClass.isInterface())
                {
                    if (lg_classAdded) p_newInstancesBuffer.append(SPACER+"else\r\n");

                    String s_str = MACRO_NEWINSTANCE.replace((CharSequence)"%%CLASS_NAME%%", (CharSequence)s_className);
                    s_str = s_str.replace((CharSequence)"%%SUNCLASS_NAME%%", (CharSequence)s_sunClassName);

                    p_newInstancesBuffer.append(s_str);

                    lg_classAdded = true;
                }

                Field [] ap_staticFields = getFields(p_class, true);
                Field [] ap_dynamicFields = getFields(p_class,false);
                Method [] ap_staticMethods = getMethods(p_class, true);
                Method [] ap_dynamicMethods = getMethods(p_class, false);

               
                // fill static fields
                if (ap_staticFields.length>0)
                {
                    p_staticFieldsBuffer.append(s_classHeader);

                    for(int lf=0;lf<ap_staticFields.length;lf++)
                    {
                        if (!lg_Working) return;

                        Field p_field = ap_staticFields[lf];

                        String s_fieldNormalName = field2str(p_field);

                        String s_fieldID = makeFieldName(s_sunClassName, p_field);
                        if (lf>0)
                        {
                            p_staticFieldsBuffer.append(SPACER);
                            p_staticFieldsBuffer.append("else\r\n");
                        }

                        String s_str = MACRO_FIELD.replace((CharSequence)"%%FIELD_NAME%%", (CharSequence)s_fieldID);
                        s_str = s_str.replace((CharSequence)"%%NORMALFIELD_NAME%%", (CharSequence)s_fieldNormalName);

                        p_staticFieldsBuffer.append(s_str);
                    }
                }

                // fill dynamic fields
                if (ap_dynamicFields.length>0)
                {
                    p_synamicFieldsBuffer.append(s_classHeader);

                    for(int lf=0;lf<ap_dynamicFields.length;lf++)
                    {
                        if (!lg_Working) return;

                        Field p_field = ap_dynamicFields[lf];
                        String s_fieldNormalName = field2str(p_field);

                        String s_fieldID = makeFieldName(s_sunClassName, p_field);

                        if (lf>0)
                        {
                            p_synamicFieldsBuffer.append(SPACER);
                            p_synamicFieldsBuffer.append("else\r\n");
                        }


                        String s_str = MACRO_FIELD.replace((CharSequence)"%%FIELD_NAME%%", (CharSequence)s_fieldID);
                        s_str = s_str.replace((CharSequence)"%%NORMALFIELD_NAME%%", (CharSequence)s_fieldNormalName);

                        p_synamicFieldsBuffer.append(s_str);
                    }
                }

                // fill static methods
                if (ap_staticMethods.length>0)
                {
                    p_staticMethodsBuffer.append(s_classHeader);

                    for(int lf=0;lf<ap_staticMethods.length;lf++)
                    {
                        if (!lg_Working) return;

                        Method p_method = ap_staticMethods[lf];

                        String s_methodID = makeMethodName(s_sunClassName, p_method);
                        String s_methodNormalName = method2str(p_method);

                        if (lf>0)
                        {
                            p_staticMethodsBuffer.append(SPACER);
                            p_staticMethodsBuffer.append("else\r\n");
                        }

                        String s_str = MACRO_METHOD.replace((CharSequence)"%%METHOD_NAME%%", (CharSequence)s_methodID);
                        s_str = s_str.replace((CharSequence)"%%NORMALMETHOD_NAME%%", (CharSequence)s_methodNormalName);

                        p_staticMethodsBuffer.append(s_str);
                    }
                }

                // fill dynamic methods
                if (ap_dynamicMethods.length>0)
                {
                    p_dynamicMethodsBuffer.append(s_classHeader);

                    for(int lf=0;lf<ap_dynamicMethods.length;lf++)
                    {
                        if (!lg_Working) return;

                        Method p_method = ap_dynamicMethods[lf];

                        String s_methodID = makeMethodName(s_sunClassName, p_method);
                        String s_methodNormalName = method2str(p_method);

                        if (lf>0)
                        {
                            p_dynamicMethodsBuffer.append(SPACER);
                            p_dynamicMethodsBuffer.append("else\r\n");
                        }

                        String s_str = MACRO_METHOD.replace((CharSequence)"%%METHOD_NAME%%", (CharSequence)s_methodID);
                        s_str = s_str.replace((CharSequence)"%%NORMALMETHOD_NAME%%", (CharSequence)s_methodNormalName);

                        p_dynamicMethodsBuffer.append(s_str);
                    }
                }

            }

            s_template = s_template.replace((CharSequence)MACROS_DYNAMICFIELDS,(CharSequence)p_synamicFieldsBuffer.toString());
            s_template = s_template.replace((CharSequence)MACROS_DYNAMICMETHODS,(CharSequence)p_dynamicMethodsBuffer.toString());
            s_template = s_template.replace((CharSequence)MACROS_NEWINSTANCES,(CharSequence)p_newInstancesBuffer.toString());
            s_template = s_template.replace((CharSequence)MACROS_STATICFIELDS,(CharSequence)p_staticFieldsBuffer.toString());
            s_template = s_template.replace((CharSequence)MACROS_STATICMETHODS,(CharSequence)p_staticMethodsBuffer.toString());

            s_Result = s_template;
        }
        catch (Throwable ex)
        {
            ex.printStackTrace();

            s_Error = ex.getMessage();
            s_Result = null;

            return;
        }
        finally
        {
            setVisible(false);
        }
    }

    protected String makeFieldName(String _className,Field _field)
    {
        return _className+'.'+_field.getName()+'.'+_field.getSignature();
    }

    protected String makeMethodName(String _className,Method _method)
    {
        return _className+'.'+_method.getName()+'.'+_method.getSignature();
    }

    protected Field [] getFields(ClassItem _classItem,boolean _static)
    {
        TreeSet <Field> p_treeSet = new TreeSet<Field>(new Comparator<Field>(){

            @Override
            public int compare(Field o1, Field o2)
            {
                return o1.getName().compareTo(o2.getName());
            }
        });

        Field [] ap_fields = _classItem.getJavaClass().getFields();
        for(int li=0;li<ap_fields.length;li++)
        {
            Field p_field = ap_fields[li];
            if (_static)
            {
                if (p_field.isStatic())
                {
                    p_treeSet.add(p_field);
                }
            }
            else
            {
                if (!p_field.isStatic())
                {
                    p_treeSet.add(p_field);
                }
            }
        }

        return p_treeSet.toArray(new Field[p_treeSet.size()]);
    }

    protected Method [] getMethods(ClassItem _classItem,boolean _static)
    {
        TreeSet <Method> p_treeSet = new TreeSet<Method>(new Comparator<Method>(){

            @Override
            public int compare(Method o1, Method o2)
            {
                String s_name = o1.getName();
                String s_name2 = o2.getName();

                if (s_name.equals(s_name2)) return 1;

                return o1.getName().compareTo(o2.getName());
            }
        });

        Method [] ap_methods = _classItem.getJavaClass().getMethods();
        for(int li=0;li<ap_methods.length;li++)
        {
            Method p_method = ap_methods[li];
            if (p_method.isPrivate()) continue;

            if (_static)
            {
                if (p_method.isStatic())
                {
                    p_treeSet.add(p_method);
                }
            }
            else
            {
                if (!p_method.isStatic())
                {
                    p_treeSet.add(p_method);
                }
            }
        }

        return p_treeSet.toArray(new Method[p_treeSet.size()]);
    }

    protected String field2str(Field _field)
    {
        String s_modifier = "";

        if (_field.isPrivate())
        {
            s_modifier = "private ";
        }
        else
        if (_field.isProtected())
        {
            s_modifier = "protected ";
        }
        else
        if (_field.isPublic())
        {
            s_modifier = "public ";
        }

        if (_field.isStatic())
        {
            s_modifier += "static ";
        }

        if (_field.isFinal())
        {
            s_modifier += "final ";
        }

        s_modifier += _field.getType().toString();

        s_modifier += ' '+_field.getName();

        return s_modifier;
    }

    protected String method2str(Method _method)
    {
        String s_modifier = "";

        if (_method.isPrivate())
        {
            s_modifier = "private ";
        }
        else
        if (_method.isProtected())
        {
            s_modifier = "protected ";
        }
        else
        if (_method.isPublic())
        {
            s_modifier = "public ";
        }

        if (_method.isStatic())
        {
            s_modifier += "static ";
        }

        if (_method.isFinal())
        {
            s_modifier += "final ";
        }

        s_modifier += _method.getReturnType().toString();

        s_modifier += ' '+_method.getName();

        StringBuilder p_args = new StringBuilder();
        Type [] ap_types = _method.getArgumentTypes();

        for(int li=0;li<ap_types.length;li++)
        {
            if (li>0) p_args.append(", ");
            p_args.append(ap_types[li].toString());
        }

        s_modifier += '('+p_args.toString()+')';

        return s_modifier;
    }

}
